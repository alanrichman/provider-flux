//go:build !ignore_autogenerated

// SPDX-FileCopyrightText: 2024 The Crossplane Authors <https://crossplane.io>
//
// SPDX-License-Identifier: Apache-2.0

// Code generated by controller-gen. DO NOT EDIT.

package v1alpha1

import (
	runtime "k8s.io/apimachinery/pkg/runtime"
)

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *Git) DeepCopyInto(out *Git) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
	in.Spec.DeepCopyInto(&out.Spec)
	in.Status.DeepCopyInto(&out.Status)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new Git.
func (in *Git) DeepCopy() *Git {
	if in == nil {
		return nil
	}
	out := new(Git)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *Git) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitInitParameters) DeepCopyInto(out *GitInitParameters) {
	*out = *in
	if in.ClusterDomain != nil {
		in, out := &in.ClusterDomain, &out.ClusterDomain
		*out = new(string)
		**out = **in
	}
	if in.Components != nil {
		in, out := &in.Components, &out.Components
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ComponentsExtra != nil {
		in, out := &in.ComponentsExtra, &out.ComponentsExtra
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.DeleteGitManifests != nil {
		in, out := &in.DeleteGitManifests, &out.DeleteGitManifests
		*out = new(bool)
		**out = **in
	}
	if in.DisableSecretCreation != nil {
		in, out := &in.DisableSecretCreation, &out.DisableSecretCreation
		*out = new(bool)
		**out = **in
	}
	if in.EmbeddedManifests != nil {
		in, out := &in.EmbeddedManifests, &out.EmbeddedManifests
		*out = new(bool)
		**out = **in
	}
	if in.ImagePullSecret != nil {
		in, out := &in.ImagePullSecret, &out.ImagePullSecret
		*out = new(string)
		**out = **in
	}
	if in.Interval != nil {
		in, out := &in.Interval, &out.Interval
		*out = new(string)
		**out = **in
	}
	if in.KeepNamespace != nil {
		in, out := &in.KeepNamespace, &out.KeepNamespace
		*out = new(bool)
		**out = **in
	}
	if in.KustomizationOverride != nil {
		in, out := &in.KustomizationOverride, &out.KustomizationOverride
		*out = new(string)
		**out = **in
	}
	if in.LogLevel != nil {
		in, out := &in.LogLevel, &out.LogLevel
		*out = new(string)
		**out = **in
	}
	if in.ManifestsPath != nil {
		in, out := &in.ManifestsPath, &out.ManifestsPath
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.NetworkPolicy != nil {
		in, out := &in.NetworkPolicy, &out.NetworkPolicy
		*out = new(bool)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.RecurseSubmodules != nil {
		in, out := &in.RecurseSubmodules, &out.RecurseSubmodules
		*out = new(bool)
		**out = **in
	}
	if in.Registry != nil {
		in, out := &in.Registry, &out.Registry
		*out = new(string)
		**out = **in
	}
	if in.RegistryCredentials != nil {
		in, out := &in.RegistryCredentials, &out.RegistryCredentials
		*out = new(string)
		**out = **in
	}
	if in.SecretName != nil {
		in, out := &in.SecretName, &out.SecretName
		*out = new(string)
		**out = **in
	}
	if in.TolerationKeys != nil {
		in, out := &in.TolerationKeys, &out.TolerationKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WatchAllNamespaces != nil {
		in, out := &in.WatchAllNamespaces, &out.WatchAllNamespaces
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitInitParameters.
func (in *GitInitParameters) DeepCopy() *GitInitParameters {
	if in == nil {
		return nil
	}
	out := new(GitInitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitList) DeepCopyInto(out *GitList) {
	*out = *in
	out.TypeMeta = in.TypeMeta
	in.ListMeta.DeepCopyInto(&out.ListMeta)
	if in.Items != nil {
		in, out := &in.Items, &out.Items
		*out = make([]Git, len(*in))
		for i := range *in {
			(*in)[i].DeepCopyInto(&(*out)[i])
		}
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitList.
func (in *GitList) DeepCopy() *GitList {
	if in == nil {
		return nil
	}
	out := new(GitList)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
func (in *GitList) DeepCopyObject() runtime.Object {
	if c := in.DeepCopy(); c != nil {
		return c
	}
	return nil
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitObservation) DeepCopyInto(out *GitObservation) {
	*out = *in
	if in.ClusterDomain != nil {
		in, out := &in.ClusterDomain, &out.ClusterDomain
		*out = new(string)
		**out = **in
	}
	if in.Components != nil {
		in, out := &in.Components, &out.Components
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ComponentsExtra != nil {
		in, out := &in.ComponentsExtra, &out.ComponentsExtra
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.DeleteGitManifests != nil {
		in, out := &in.DeleteGitManifests, &out.DeleteGitManifests
		*out = new(bool)
		**out = **in
	}
	if in.DisableSecretCreation != nil {
		in, out := &in.DisableSecretCreation, &out.DisableSecretCreation
		*out = new(bool)
		**out = **in
	}
	if in.EmbeddedManifests != nil {
		in, out := &in.EmbeddedManifests, &out.EmbeddedManifests
		*out = new(bool)
		**out = **in
	}
	if in.ID != nil {
		in, out := &in.ID, &out.ID
		*out = new(string)
		**out = **in
	}
	if in.ImagePullSecret != nil {
		in, out := &in.ImagePullSecret, &out.ImagePullSecret
		*out = new(string)
		**out = **in
	}
	if in.Interval != nil {
		in, out := &in.Interval, &out.Interval
		*out = new(string)
		**out = **in
	}
	if in.KeepNamespace != nil {
		in, out := &in.KeepNamespace, &out.KeepNamespace
		*out = new(bool)
		**out = **in
	}
	if in.KustomizationOverride != nil {
		in, out := &in.KustomizationOverride, &out.KustomizationOverride
		*out = new(string)
		**out = **in
	}
	if in.LogLevel != nil {
		in, out := &in.LogLevel, &out.LogLevel
		*out = new(string)
		**out = **in
	}
	if in.ManifestsPath != nil {
		in, out := &in.ManifestsPath, &out.ManifestsPath
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.NetworkPolicy != nil {
		in, out := &in.NetworkPolicy, &out.NetworkPolicy
		*out = new(bool)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.RecurseSubmodules != nil {
		in, out := &in.RecurseSubmodules, &out.RecurseSubmodules
		*out = new(bool)
		**out = **in
	}
	if in.Registry != nil {
		in, out := &in.Registry, &out.Registry
		*out = new(string)
		**out = **in
	}
	if in.RegistryCredentials != nil {
		in, out := &in.RegistryCredentials, &out.RegistryCredentials
		*out = new(string)
		**out = **in
	}
	if in.RepositoryFiles != nil {
		in, out := &in.RepositoryFiles, &out.RepositoryFiles
		*out = make(map[string]*string, len(*in))
		for key, val := range *in {
			var outVal *string
			if val == nil {
				(*out)[key] = nil
			} else {
				inVal := (*in)[key]
				in, out := &inVal, &outVal
				*out = new(string)
				**out = **in
			}
			(*out)[key] = outVal
		}
	}
	if in.SecretName != nil {
		in, out := &in.SecretName, &out.SecretName
		*out = new(string)
		**out = **in
	}
	if in.TolerationKeys != nil {
		in, out := &in.TolerationKeys, &out.TolerationKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WatchAllNamespaces != nil {
		in, out := &in.WatchAllNamespaces, &out.WatchAllNamespaces
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitObservation.
func (in *GitObservation) DeepCopy() *GitObservation {
	if in == nil {
		return nil
	}
	out := new(GitObservation)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitParameters) DeepCopyInto(out *GitParameters) {
	*out = *in
	if in.ClusterDomain != nil {
		in, out := &in.ClusterDomain, &out.ClusterDomain
		*out = new(string)
		**out = **in
	}
	if in.Components != nil {
		in, out := &in.Components, &out.Components
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.ComponentsExtra != nil {
		in, out := &in.ComponentsExtra, &out.ComponentsExtra
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.DeleteGitManifests != nil {
		in, out := &in.DeleteGitManifests, &out.DeleteGitManifests
		*out = new(bool)
		**out = **in
	}
	if in.DisableSecretCreation != nil {
		in, out := &in.DisableSecretCreation, &out.DisableSecretCreation
		*out = new(bool)
		**out = **in
	}
	if in.EmbeddedManifests != nil {
		in, out := &in.EmbeddedManifests, &out.EmbeddedManifests
		*out = new(bool)
		**out = **in
	}
	if in.ImagePullSecret != nil {
		in, out := &in.ImagePullSecret, &out.ImagePullSecret
		*out = new(string)
		**out = **in
	}
	if in.Interval != nil {
		in, out := &in.Interval, &out.Interval
		*out = new(string)
		**out = **in
	}
	if in.KeepNamespace != nil {
		in, out := &in.KeepNamespace, &out.KeepNamespace
		*out = new(bool)
		**out = **in
	}
	if in.KustomizationOverride != nil {
		in, out := &in.KustomizationOverride, &out.KustomizationOverride
		*out = new(string)
		**out = **in
	}
	if in.LogLevel != nil {
		in, out := &in.LogLevel, &out.LogLevel
		*out = new(string)
		**out = **in
	}
	if in.ManifestsPath != nil {
		in, out := &in.ManifestsPath, &out.ManifestsPath
		*out = new(string)
		**out = **in
	}
	if in.Namespace != nil {
		in, out := &in.Namespace, &out.Namespace
		*out = new(string)
		**out = **in
	}
	if in.NetworkPolicy != nil {
		in, out := &in.NetworkPolicy, &out.NetworkPolicy
		*out = new(bool)
		**out = **in
	}
	if in.Path != nil {
		in, out := &in.Path, &out.Path
		*out = new(string)
		**out = **in
	}
	if in.RecurseSubmodules != nil {
		in, out := &in.RecurseSubmodules, &out.RecurseSubmodules
		*out = new(bool)
		**out = **in
	}
	if in.Registry != nil {
		in, out := &in.Registry, &out.Registry
		*out = new(string)
		**out = **in
	}
	if in.RegistryCredentials != nil {
		in, out := &in.RegistryCredentials, &out.RegistryCredentials
		*out = new(string)
		**out = **in
	}
	if in.SecretName != nil {
		in, out := &in.SecretName, &out.SecretName
		*out = new(string)
		**out = **in
	}
	if in.TolerationKeys != nil {
		in, out := &in.TolerationKeys, &out.TolerationKeys
		*out = make([]*string, len(*in))
		for i := range *in {
			if (*in)[i] != nil {
				in, out := &(*in)[i], &(*out)[i]
				*out = new(string)
				**out = **in
			}
		}
	}
	if in.Version != nil {
		in, out := &in.Version, &out.Version
		*out = new(string)
		**out = **in
	}
	if in.WatchAllNamespaces != nil {
		in, out := &in.WatchAllNamespaces, &out.WatchAllNamespaces
		*out = new(bool)
		**out = **in
	}
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitParameters.
func (in *GitParameters) DeepCopy() *GitParameters {
	if in == nil {
		return nil
	}
	out := new(GitParameters)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitSpec) DeepCopyInto(out *GitSpec) {
	*out = *in
	in.ResourceSpec.DeepCopyInto(&out.ResourceSpec)
	in.ForProvider.DeepCopyInto(&out.ForProvider)
	in.InitProvider.DeepCopyInto(&out.InitProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitSpec.
func (in *GitSpec) DeepCopy() *GitSpec {
	if in == nil {
		return nil
	}
	out := new(GitSpec)
	in.DeepCopyInto(out)
	return out
}

// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
func (in *GitStatus) DeepCopyInto(out *GitStatus) {
	*out = *in
	in.ResourceStatus.DeepCopyInto(&out.ResourceStatus)
	in.AtProvider.DeepCopyInto(&out.AtProvider)
}

// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new GitStatus.
func (in *GitStatus) DeepCopy() *GitStatus {
	if in == nil {
		return nil
	}
	out := new(GitStatus)
	in.DeepCopyInto(out)
	return out
}
